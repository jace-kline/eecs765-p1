# EECS 765 Project 1

## Introduction

The purpose of this programming assignment is to practice the development and execution of a remote buffer overflow attack on a vulnerable webserver deployed on RedHat 8 Linux. We also explore an additional attack on RedHat 9 that emplmitigation technique called stack address randomization.

## Environment Setup

The first step in developing an exploit is properly configuring an environment that accurately portrays the environment used in a live attack scenario. We first set up an environment following the constraints given in the programming assignment description. We create a NAT subnet 192.168.180.0 in VMWare and assign the static IP addresses of 192.168.180.10, 192.168.180.40, and 192.168.180.50 to the Kali, RedHat 8, and RedHat 9 VMs, respectively. Next, we ensure that each machine can reach all the others via netcat. We also start the nweb servers on the RedHat 8 and RedHat 9 machines by navigating to the /root directory and running `./nweb 8888 .`, and then we ensure that the webservers are accessible from the Kali VM. For efficiency of attack development, we also set up SSH for each of these machines.

## Running the Exploit

The exploits work in both the RedHat 8 and RedHat 9 attack scenarios. The IP addresses used in the exploits were identical to those specified in the PA1 description (shown in the environment setup above). We use port 8228 on the Kali VM to listen for the reverse shell TCP connection. The steps for running each of the exploits are below. We assume that for each attack, the environment is properly configured and the victim VM is running the nweb webserver on port 8888. We assume that the working directory on the Kali VM is at the root of the unzipped project code folder.

First, navigate to the target exploit folder in the current shell. For the RedHat 8 exploit, run `cd redhat8`. For the RedHat 9 exploit, run `cd redhat9`. Each of these directories has the same structure and includes `exploit.sh` and `generate_shellcode.py` files specific to each of these attacks.

Next, open another shell on the Kali machine. In this shell, we want to set up a listener to receive the callback TCP connection from the reverse shell that will be spawned on the victim during the attack. We use netcat to achieve this, and we specify port 8228 to listen on.

```sh
nc -nlvp 8228
```

Next, we return back to the other shell to run the exploit. Run the `exploit.sh` shell script to generate and send the malicious input to the webserver on the victim machine. The contents of `exploit.sh` are shown in the 'Developing the Exploit' section below. Specifically, we run the following command:

```sh
./exploit.sh
```

After sending the malicious input above, return attention to the listener shell. After a slight delay, there should be a message that indicates a connection initiated from the victim machine. The RedHat 8 exploit should result in a TCP connection from IP address 192.168.180.40. The RedHat 9 exploit should result in a TCP connection from IP address 192.168.180.50. In this listener shell, run some test commands such as `whoami` and `ls` to verify that the reverse shell (as root user) has been established successfully.  Below, we show that the results from successful exploits targeted at both the RedHat 8 and RedHat 9 victim machines.

<img src="./screenshots/redhat8-exploit.png?raw=true" width="45%"/>

<img src="./screenshots/redhat9-exploit.png?raw=true" width="45%"/>

## Developing the Exploit

### Malicious Input Structure

#### RedHat 8

Since RedHat 8 does not use stack randomization, we can place our shellcode directly in the overflowed buffer since the buffer's start address remains consistent across runs. This consistency of the vulnerable buffer's start address allows us to compute this, and subsequently compute the offset from the buffer start to the saved EIP location. Using these parameters, we construct the malicious input by filling roughly the first third of the buffer with NOP sled bytes (0x90), then appending the shellcode generated by Metasploit, and then filling the remaining bytes of the offset (overwriting the saved EIP) with a return address that exists within the NOP sled. In addition, we ensure that the first byte of the shellcode aligns with a word boundary (1 word = 4 bytes) as well as the modified return address used to overwrite the saved EIP.

#### RedHat 9

The stack randomization used in RedHat 9 requires us to take a different approach to executing our shellcode. Although the start of the buffer in this attack is unknown between runs, we know the offset remains consistent (same as RedHat 8 exploit). The ultimate goal is to place the shellcode somewhere after the $ESP with a NOP sled starting at $ESP that will ultimately lead to execution of the subsequent shellcode. We find a sequence of 2 bytes in shared (static) memory that contains the bytes corresponding the instruction `JMP $ESP`, which is 0xffe4, and then find the corresponding memory address that contains this sequence. We use this address to overwrite the saved EIP in our exploit. Knowing that the nweb binary uses the libc library via the `ldd nweb` command, we use the `./searchJmpCode` program provided by Dr. Bardas to list locations that contain the bytes '0xffe4'. After obtaining a valid address, we construct the malicious input as the of repetition of arbitrary bytes to overflow the buffer + the overwriting of the saved EIP with the address containing '0xffe4' + a NOP sled (starts at $ESP) + the generated shellcode (same as RedHat 8 exploit).

### Malicious Input Parameters

What are the paramaters you need to determine and why? e.g., little or big endian architecture, buffer length, distance to saved_EIP, value stored in saved_EIP, etc.
How did you determine the values for the above-mentioned paramaters?

For the RedHat 8 exploit, we must find the endianness of the architecture, the address of the start of the buffer, and the offset from the start of the buffer to the saved EIP location. We know that the endianness of the x86 architecture is little endian. 

To compute the address of the start of the buffer, we simply use an input of 1500 'A' (0x41) bytes such that a segmentation fault occurs and the core is dumped. Using the `gdb` tool, we analyze the memory to find the address of the first occurence of the 0x41 byte. We repeat this using 'B' bytes (0x42) to cross check our results. We find that the start address of the buffer is 0xbffff6a4.

To compute the offset from the start of the buffer to the saved EIP location, we first use the Metasploit's `pattern_create.rb` Ruby script to generate input using the command `EGG=$(/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1500)`. We then send the malicious input to the webserver, which causes a segmentation fault and core dump. Using `gdb` on the core file, we 

For the RedHat 9 exploit, we use the endianness of the architecture, the offset from the start of the buffer to the saved EIP location, and the distance from the saved EIP location to the $ESP pointer address.

### Generating the Malicious Input

What programming language did you use?
How did you construct the malicious input? (brief description)

## References and Collaborations

Specify your online or hardcopy sources of information (especially if your exploit is based on someone else's source code - should NOT be a classmate)
List the people that you discussed the programming assignment with. Also, add a very brief description of what you discussed with each individual. Don't forget that programming assignments are individual assignments
